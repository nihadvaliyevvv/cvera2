const axios = require('axios');
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient();

// LinkedIn profile URLs to scrape
const linkedinProfiles = [
    "https://www.linkedin.com/in/elad-moshe-05a90413/",
    "https://www.linkedin.com/in/jonathan-myrvik-3baa01109",
    "https://www.linkedin.com/in/aviv-tal-75b81/",
    "https://www.linkedin.com/in/bulentakar/"
];

// Extract LinkedIn ID from URL
function extractLinkedInId(url) {
    const match = url.match(/linkedin\.com\/in\/([^\/]+)/);
    return match ? match[1] : null;
}

// ScrapingDog API scraper
async function scrapeWithScrapingDog(linkedinId, apiKey) {
    try {
        console.log(`🐕 Trying ScrapingDog API for: ${linkedinId}`);

        const params = {
            api_key: apiKey,
            type: 'profile',
            linkId: linkedinId,
            premium: 'false',
        };

        const response = await axios.get('https://api.scrapingdog.com/linkedin', { params });

        if (response.status === 200 && response.data) {
            console.log(`✅ ScrapingDog success for: ${linkedinId}`);
            return {
                success: true,
                data: response.data,
                service: 'scrapingdog'
            };
        } else {
            throw new Error(`ScrapingDog returned status: ${response.status}`);
        }
    } catch (error) {
        console.log(`❌ ScrapingDog failed for ${linkedinId}:`, error.message);
        return {
            success: false,
            error: error.message,
            service: 'scrapingdog'
        };
    }
}

// BrightData API scraper (fallback)
async function scrapeWithBrightData(profileUrls, apiKey) {
    try {
        console.log(`🌟 Trying BrightData API for ${profileUrls.length} profiles`);

        const data = JSON.stringify(profileUrls.map(url => ({ url })));

        const response = await fetch(
            "https://api.brightdata.com/datasets/v3/trigger?dataset_id=gd_l1viktl72bvl7bjuj0&include_errors=true",
            {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json",
                },
                body: data,
            }
        );

        const result = await response.json();

        if (response.ok && result) {
            console.log(`✅ BrightData success for ${profileUrls.length} profiles`);
            return {
                success: true,
                data: result,
                service: 'brightdata'
            };
        } else {
            throw new Error(`BrightData returned status: ${response.status}`);
        }
    } catch (error) {
        console.log(`❌ BrightData failed:`, error.message);
        return {
            success: false,
            error: error.message,
            service: 'brightdata'
        };
    }
}

// Get active API key from database
async function getActiveApiKey(service) {
    try {
        const apiKey = await prisma.apiKey.findFirst({
            where: {
                service: service,
                active: true
            },
            orderBy: {
                priority: 'asc'
            }
        });

        return apiKey?.apiKey || null;
    } catch (error) {
        console.error(`❌ Error getting ${service} API key:`, error);
        return null;
    }
}

// Update API key usage
async function updateApiKeyUsage(service, success, errorMessage = null) {
    try {
        await prisma.apiKey.updateMany({
            where: {
                service: service,
                active: true
            },
            data: {
                usageCount: {
                    increment: 1
                },
                dailyUsage: {
                    increment: 1
                },
                lastUsed: new Date(),
                lastResult: success ? 'success' : 'failure',
                lastError: errorMessage
            }
        });
    } catch (error) {
        console.error(`❌ Error updating ${service} API usage:`, error);
    }
}

// Main scraping function with fallback
async function scrapeLinkedInProfiles() {
    console.log('🚀 Starting LinkedIn profile scraping...');

    const results = [];

    // Try ScrapingDog for each profile first
    const scrapingDogApiKey = await getActiveApiKey('scrapingdog');

    if (scrapingDogApiKey) {
        console.log('📡 Using ScrapingDog API as primary method');

        for (const profileUrl of linkedinProfiles) {
            const linkedinId = extractLinkedInId(profileUrl);
            if (!linkedinId) {
                console.log(`❌ Could not extract LinkedIn ID from: ${profileUrl}`);
                continue;
            }

            const result = await scrapeWithScrapingDog(linkedinId, scrapingDogApiKey);
            await updateApiKeyUsage('scrapingdog', result.success, result.error);

            if (result.success) {
                results.push({
                    profile: profileUrl,
                    data: result.data,
                    service: 'scrapingdog'
                });
            } else {
                // If ScrapingDog fails for this profile, we'll try BrightData later
                results.push({
                    profile: profileUrl,
                    data: null,
                    service: 'scrapingdog',
                    error: result.error,
                    needsFallback: true
                });
            }

            // Add delay between requests
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    } else {
        console.log('❌ No active ScrapingDog API key found');
    }

    // Check if we need to use BrightData fallback
    const failedProfiles = results
        .filter(r => r.needsFallback)
        .map(r => r.profile);

    if (failedProfiles.length > 0) {
        console.log(`🔄 ${failedProfiles.length} profiles failed with ScrapingDog, trying BrightData...`);

        const brightDataApiKey = await getActiveApiKey('brightdata');

        if (brightDataApiKey) {
            const brightDataResult = await scrapeWithBrightData(failedProfiles, brightDataApiKey);
            await updateApiKeyUsage('brightdata', brightDataResult.success, brightDataResult.error);

            if (brightDataResult.success) {
                console.log('✅ BrightData fallback successful');

                // Update results with BrightData data
                failedProfiles.forEach((profile, index) => {
                    const resultIndex = results.findIndex(r => r.profile === profile);
                    if (resultIndex !== -1) {
                        results[resultIndex] = {
                            profile: profile,
                            data: brightDataResult.data,
                            service: 'brightdata'
                        };
                    }
                });
            } else {
                console.log('❌ BrightData fallback also failed');
            }
        } else {
            console.log('❌ No active BrightData API key found');
        }
    }

    // Display results
    console.log('\n📊 SCRAPING RESULTS:');
    console.log('===================');

    results.forEach((result, index) => {
        console.log(`\n${index + 1}. ${result.profile}`);
        console.log(`   Service: ${result.service}`);
        console.log(`   Status: ${result.data ? '✅ Success' : '❌ Failed'}`);
        if (result.error) {
            console.log(`   Error: ${result.error}`);
        }
        if (result.data) {
            console.log(`   Data: ${JSON.stringify(result.data).substring(0, 200)}...`);
        }
    });

    await prisma.$disconnect();
    return results;
}

// Run the scraper
scrapeLinkedInProfiles()
    .then((results) => {
        console.log('\n✅ Scraping completed successfully');
        console.log(`📊 Total profiles processed: ${results.length}`);
        console.log(`✅ Successful scrapes: ${results.filter(r => r.data).length}`);
        console.log(`❌ Failed scrapes: ${results.filter(r => !r.data).length}`);
    })
    .catch((error) => {
        console.error('❌ Scraping failed:', error);
    });
